// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <cxx/pre.hxx>

#include "scene.hxx"

// sceneInterface
// 

const sceneInterface::camera_sequence& sceneInterface::
camera () const
{
  return this->camera_;
}

sceneInterface::camera_sequence& sceneInterface::
camera ()
{
  return this->camera_;
}

void sceneInterface::
camera (const camera_sequence& s)
{
  this->camera_ = s;
}

const sceneInterface::light_sequence& sceneInterface::
light () const
{
  return this->light_;
}

sceneInterface::light_sequence& sceneInterface::
light ()
{
  return this->light_;
}

void sceneInterface::
light (const light_sequence& s)
{
  this->light_ = s;
}

const sceneInterface::sphere_sequence& sceneInterface::
sphere () const
{
  return this->sphere_;
}

sceneInterface::sphere_sequence& sceneInterface::
sphere ()
{
  return this->sphere_;
}

void sceneInterface::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const sceneInterface::elipsoid_sequence& sceneInterface::
elipsoid () const
{
  return this->elipsoid_;
}

sceneInterface::elipsoid_sequence& sceneInterface::
elipsoid ()
{
  return this->elipsoid_;
}

void sceneInterface::
elipsoid (const elipsoid_sequence& s)
{
  this->elipsoid_ = s;
}

const sceneInterface::plane_sequence& sceneInterface::
plane () const
{
  return this->plane_;
}

sceneInterface::plane_sequence& sceneInterface::
plane ()
{
  return this->plane_;
}

void sceneInterface::
plane (const plane_sequence& s)
{
  this->plane_ = s;
}

const sceneInterface::frames_type& sceneInterface::
frames () const
{
  return this->frames_.get ();
}

sceneInterface::frames_type& sceneInterface::
frames ()
{
  return this->frames_.get ();
}

void sceneInterface::
frames (const frames_type& x)
{
  this->frames_.set (x);
}

const sceneInterface::width_type& sceneInterface::
width () const
{
  return this->width_.get ();
}

sceneInterface::width_type& sceneInterface::
width ()
{
  return this->width_.get ();
}

void sceneInterface::
width (const width_type& x)
{
  this->width_.set (x);
}

sceneInterface::width_type sceneInterface::
width_default_value ()
{
  return width_type (800LL);
}

const sceneInterface::height_type& sceneInterface::
height () const
{
  return this->height_.get ();
}

sceneInterface::height_type& sceneInterface::
height ()
{
  return this->height_.get ();
}

void sceneInterface::
height (const height_type& x)
{
  this->height_.set (x);
}

sceneInterface::height_type sceneInterface::
height_default_value ()
{
  return height_type (600LL);
}

const sceneInterface::w_type& sceneInterface::
w () const
{
  return this->w_.get ();
}

sceneInterface::w_type& sceneInterface::
w ()
{
  return this->w_.get ();
}

void sceneInterface::
w (const w_type& x)
{
  this->w_.set (x);
}

const sceneInterface::h_type& sceneInterface::
h () const
{
  return this->h_.get ();
}

sceneInterface::h_type& sceneInterface::
h ()
{
  return this->h_.get ();
}

void sceneInterface::
h (const h_type& x)
{
  this->h_.set (x);
}

const sceneInterface::d_type& sceneInterface::
d () const
{
  return this->d_.get ();
}

sceneInterface::d_type& sceneInterface::
d ()
{
  return this->d_.get ();
}

void sceneInterface::
d (const d_type& x)
{
  this->d_.set (x);
}

const sceneInterface::bred_type& sceneInterface::
bred () const
{
  return this->bred_.get ();
}

sceneInterface::bred_type& sceneInterface::
bred ()
{
  return this->bred_.get ();
}

void sceneInterface::
bred (const bred_type& x)
{
  this->bred_.set (x);
}

sceneInterface::bred_type sceneInterface::
bred_default_value ()
{
  return bred_type (.5F);
}

const sceneInterface::bgreen_type& sceneInterface::
bgreen () const
{
  return this->bgreen_.get ();
}

sceneInterface::bgreen_type& sceneInterface::
bgreen ()
{
  return this->bgreen_.get ();
}

void sceneInterface::
bgreen (const bgreen_type& x)
{
  this->bgreen_.set (x);
}

sceneInterface::bgreen_type sceneInterface::
bgreen_default_value ()
{
  return bgreen_type (.5F);
}

const sceneInterface::bblue_type& sceneInterface::
bblue () const
{
  return this->bblue_.get ();
}

sceneInterface::bblue_type& sceneInterface::
bblue ()
{
  return this->bblue_.get ();
}

void sceneInterface::
bblue (const bblue_type& x)
{
  this->bblue_.set (x);
}

sceneInterface::bblue_type sceneInterface::
bblue_default_value ()
{
  return bblue_type (.5F);
}

const sceneInterface::glred_type& sceneInterface::
glred () const
{
  return this->glred_.get ();
}

sceneInterface::glred_type& sceneInterface::
glred ()
{
  return this->glred_.get ();
}

void sceneInterface::
glred (const glred_type& x)
{
  this->glred_.set (x);
}

sceneInterface::glred_type sceneInterface::
glred_default_value ()
{
  return glred_type (.5F);
}

const sceneInterface::glgreen_type& sceneInterface::
glgreen () const
{
  return this->glgreen_.get ();
}

sceneInterface::glgreen_type& sceneInterface::
glgreen ()
{
  return this->glgreen_.get ();
}

void sceneInterface::
glgreen (const glgreen_type& x)
{
  this->glgreen_.set (x);
}

sceneInterface::glgreen_type sceneInterface::
glgreen_default_value ()
{
  return glgreen_type (.5F);
}

const sceneInterface::glblue_type& sceneInterface::
glblue () const
{
  return this->glblue_.get ();
}

sceneInterface::glblue_type& sceneInterface::
glblue ()
{
  return this->glblue_.get ();
}

void sceneInterface::
glblue (const glblue_type& x)
{
  this->glblue_.set (x);
}

sceneInterface::glblue_type sceneInterface::
glblue_default_value ()
{
  return glblue_type (.5F);
}


// tweenInterface
// 

const tweenInterface::tween_sequence& tweenInterface::
tween () const
{
  return this->tween_;
}

tweenInterface::tween_sequence& tweenInterface::
tween ()
{
  return this->tween_;
}

void tweenInterface::
tween (const tween_sequence& s)
{
  this->tween_ = s;
}


// cameraInterface
// 

const cameraInterface::id_type& cameraInterface::
id () const
{
  return this->id_.get ();
}

cameraInterface::id_type& cameraInterface::
id ()
{
  return this->id_.get ();
}

void cameraInterface::
id (const id_type& x)
{
  this->id_.set (x);
}

void cameraInterface::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const cameraInterface::x_type& cameraInterface::
x () const
{
  return this->x_.get ();
}

cameraInterface::x_type& cameraInterface::
x ()
{
  return this->x_.get ();
}

void cameraInterface::
x (const x_type& x)
{
  this->x_.set (x);
}

const cameraInterface::y_type& cameraInterface::
y () const
{
  return this->y_.get ();
}

cameraInterface::y_type& cameraInterface::
y ()
{
  return this->y_.get ();
}

void cameraInterface::
y (const y_type& x)
{
  this->y_.set (x);
}

const cameraInterface::z_type& cameraInterface::
z () const
{
  return this->z_.get ();
}

cameraInterface::z_type& cameraInterface::
z ()
{
  return this->z_.get ();
}

void cameraInterface::
z (const z_type& x)
{
  this->z_.set (x);
}

const cameraInterface::vx1_type& cameraInterface::
vx1 () const
{
  return this->vx1_.get ();
}

cameraInterface::vx1_type& cameraInterface::
vx1 ()
{
  return this->vx1_.get ();
}

void cameraInterface::
vx1 (const vx1_type& x)
{
  this->vx1_.set (x);
}

cameraInterface::vx1_type cameraInterface::
vx1_default_value ()
{
  return vx1_type (0.0F);
}

const cameraInterface::vy1_type& cameraInterface::
vy1 () const
{
  return this->vy1_.get ();
}

cameraInterface::vy1_type& cameraInterface::
vy1 ()
{
  return this->vy1_.get ();
}

void cameraInterface::
vy1 (const vy1_type& x)
{
  this->vy1_.set (x);
}

cameraInterface::vy1_type cameraInterface::
vy1_default_value ()
{
  return vy1_type (0.0F);
}

const cameraInterface::vz1_type& cameraInterface::
vz1 () const
{
  return this->vz1_.get ();
}

cameraInterface::vz1_type& cameraInterface::
vz1 ()
{
  return this->vz1_.get ();
}

void cameraInterface::
vz1 (const vz1_type& x)
{
  this->vz1_.set (x);
}

cameraInterface::vz1_type cameraInterface::
vz1_default_value ()
{
  return vz1_type (0.0F);
}

const cameraInterface::vx2_type& cameraInterface::
vx2 () const
{
  return this->vx2_.get ();
}

cameraInterface::vx2_type& cameraInterface::
vx2 ()
{
  return this->vx2_.get ();
}

void cameraInterface::
vx2 (const vx2_type& x)
{
  this->vx2_.set (x);
}

cameraInterface::vx2_type cameraInterface::
vx2_default_value ()
{
  return vx2_type (0.0F);
}

const cameraInterface::vy2_type& cameraInterface::
vy2 () const
{
  return this->vy2_.get ();
}

cameraInterface::vy2_type& cameraInterface::
vy2 ()
{
  return this->vy2_.get ();
}

void cameraInterface::
vy2 (const vy2_type& x)
{
  this->vy2_.set (x);
}

cameraInterface::vy2_type cameraInterface::
vy2_default_value ()
{
  return vy2_type (0.0F);
}

const cameraInterface::vz2_type& cameraInterface::
vz2 () const
{
  return this->vz2_.get ();
}

cameraInterface::vz2_type& cameraInterface::
vz2 ()
{
  return this->vz2_.get ();
}

void cameraInterface::
vz2 (const vz2_type& x)
{
  this->vz2_.set (x);
}

cameraInterface::vz2_type cameraInterface::
vz2_default_value ()
{
  return vz2_type (0.0F);
}

const cameraInterface::vx3_type& cameraInterface::
vx3 () const
{
  return this->vx3_.get ();
}

cameraInterface::vx3_type& cameraInterface::
vx3 ()
{
  return this->vx3_.get ();
}

void cameraInterface::
vx3 (const vx3_type& x)
{
  this->vx3_.set (x);
}

cameraInterface::vx3_type cameraInterface::
vx3_default_value ()
{
  return vx3_type (0.0F);
}

const cameraInterface::vy3_type& cameraInterface::
vy3 () const
{
  return this->vy3_.get ();
}

cameraInterface::vy3_type& cameraInterface::
vy3 ()
{
  return this->vy3_.get ();
}

void cameraInterface::
vy3 (const vy3_type& x)
{
  this->vy3_.set (x);
}

cameraInterface::vy3_type cameraInterface::
vy3_default_value ()
{
  return vy3_type (0.0F);
}

const cameraInterface::vz3_type& cameraInterface::
vz3 () const
{
  return this->vz3_.get ();
}

cameraInterface::vz3_type& cameraInterface::
vz3 ()
{
  return this->vz3_.get ();
}

void cameraInterface::
vz3 (const vz3_type& x)
{
  this->vz3_.set (x);
}

cameraInterface::vz3_type cameraInterface::
vz3_default_value ()
{
  return vz3_type (0.0F);
}


// colorInterface
// 

const colorInterface::ared_type& colorInterface::
ared () const
{
  return this->ared_.get ();
}

colorInterface::ared_type& colorInterface::
ared ()
{
  return this->ared_.get ();
}

void colorInterface::
ared (const ared_type& x)
{
  this->ared_.set (x);
}

colorInterface::ared_type colorInterface::
ared_default_value ()
{
  return ared_type (.5F);
}

const colorInterface::agreen_type& colorInterface::
agreen () const
{
  return this->agreen_.get ();
}

colorInterface::agreen_type& colorInterface::
agreen ()
{
  return this->agreen_.get ();
}

void colorInterface::
agreen (const agreen_type& x)
{
  this->agreen_.set (x);
}

colorInterface::agreen_type colorInterface::
agreen_default_value ()
{
  return agreen_type (.5F);
}

const colorInterface::ablue_type& colorInterface::
ablue () const
{
  return this->ablue_.get ();
}

colorInterface::ablue_type& colorInterface::
ablue ()
{
  return this->ablue_.get ();
}

void colorInterface::
ablue (const ablue_type& x)
{
  this->ablue_.set (x);
}

colorInterface::ablue_type colorInterface::
ablue_default_value ()
{
  return ablue_type (.5F);
}

const colorInterface::dred_type& colorInterface::
dred () const
{
  return this->dred_.get ();
}

colorInterface::dred_type& colorInterface::
dred ()
{
  return this->dred_.get ();
}

void colorInterface::
dred (const dred_type& x)
{
  this->dred_.set (x);
}

colorInterface::dred_type colorInterface::
dred_default_value ()
{
  return dred_type (.5F);
}

const colorInterface::dgreen_type& colorInterface::
dgreen () const
{
  return this->dgreen_.get ();
}

colorInterface::dgreen_type& colorInterface::
dgreen ()
{
  return this->dgreen_.get ();
}

void colorInterface::
dgreen (const dgreen_type& x)
{
  this->dgreen_.set (x);
}

colorInterface::dgreen_type colorInterface::
dgreen_default_value ()
{
  return dgreen_type (.5F);
}

const colorInterface::dblue_type& colorInterface::
dblue () const
{
  return this->dblue_.get ();
}

colorInterface::dblue_type& colorInterface::
dblue ()
{
  return this->dblue_.get ();
}

void colorInterface::
dblue (const dblue_type& x)
{
  this->dblue_.set (x);
}

colorInterface::dblue_type colorInterface::
dblue_default_value ()
{
  return dblue_type (.5F);
}

const colorInterface::sred_type& colorInterface::
sred () const
{
  return this->sred_.get ();
}

colorInterface::sred_type& colorInterface::
sred ()
{
  return this->sred_.get ();
}

void colorInterface::
sred (const sred_type& x)
{
  this->sred_.set (x);
}

colorInterface::sred_type colorInterface::
sred_default_value ()
{
  return sred_type (.5F);
}

const colorInterface::sgreen_type& colorInterface::
sgreen () const
{
  return this->sgreen_.get ();
}

colorInterface::sgreen_type& colorInterface::
sgreen ()
{
  return this->sgreen_.get ();
}

void colorInterface::
sgreen (const sgreen_type& x)
{
  this->sgreen_.set (x);
}

colorInterface::sgreen_type colorInterface::
sgreen_default_value ()
{
  return sgreen_type (.5F);
}

const colorInterface::sblue_type& colorInterface::
sblue () const
{
  return this->sblue_.get ();
}

colorInterface::sblue_type& colorInterface::
sblue ()
{
  return this->sblue_.get ();
}

void colorInterface::
sblue (const sblue_type& x)
{
  this->sblue_.set (x);
}

colorInterface::sblue_type colorInterface::
sblue_default_value ()
{
  return sblue_type (.5F);
}


// objectInterface
// 

const objectInterface::id_type& objectInterface::
id () const
{
  return this->id_.get ();
}

objectInterface::id_type& objectInterface::
id ()
{
  return this->id_.get ();
}

void objectInterface::
id (const id_type& x)
{
  this->id_.set (x);
}

void objectInterface::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const objectInterface::x_type& objectInterface::
x () const
{
  return this->x_.get ();
}

objectInterface::x_type& objectInterface::
x ()
{
  return this->x_.get ();
}

void objectInterface::
x (const x_type& x)
{
  this->x_.set (x);
}

const objectInterface::y_type& objectInterface::
y () const
{
  return this->y_.get ();
}

objectInterface::y_type& objectInterface::
y ()
{
  return this->y_.get ();
}

void objectInterface::
y (const y_type& x)
{
  this->y_.set (x);
}

const objectInterface::z_type& objectInterface::
z () const
{
  return this->z_.get ();
}

objectInterface::z_type& objectInterface::
z ()
{
  return this->z_.get ();
}

void objectInterface::
z (const z_type& x)
{
  this->z_.set (x);
}

const objectInterface::n_type& objectInterface::
n () const
{
  return this->n_.get ();
}

objectInterface::n_type& objectInterface::
n ()
{
  return this->n_.get ();
}

void objectInterface::
n (const n_type& x)
{
  this->n_.set (x);
}

objectInterface::n_type objectInterface::
n_default_value ()
{
  return n_type (200LL);
}


// sphereInterface
// 

const sphereInterface::r_type& sphereInterface::
r () const
{
  return this->r_.get ();
}

sphereInterface::r_type& sphereInterface::
r ()
{
  return this->r_.get ();
}

void sphereInterface::
r (const r_type& x)
{
  this->r_.set (x);
}


// elipsoidInterface
// 

const elipsoidInterface::a_type& elipsoidInterface::
a () const
{
  return this->a_.get ();
}

elipsoidInterface::a_type& elipsoidInterface::
a ()
{
  return this->a_.get ();
}

void elipsoidInterface::
a (const a_type& x)
{
  this->a_.set (x);
}

const elipsoidInterface::b_type& elipsoidInterface::
b () const
{
  return this->b_.get ();
}

elipsoidInterface::b_type& elipsoidInterface::
b ()
{
  return this->b_.get ();
}

void elipsoidInterface::
b (const b_type& x)
{
  this->b_.set (x);
}

const elipsoidInterface::c_type& elipsoidInterface::
c () const
{
  return this->c_.get ();
}

elipsoidInterface::c_type& elipsoidInterface::
c ()
{
  return this->c_.get ();
}

void elipsoidInterface::
c (const c_type& x)
{
  this->c_.set (x);
}

const elipsoidInterface::vx_type& elipsoidInterface::
vx () const
{
  return this->vx_.get ();
}

elipsoidInterface::vx_type& elipsoidInterface::
vx ()
{
  return this->vx_.get ();
}

void elipsoidInterface::
vx (const vx_type& x)
{
  this->vx_.set (x);
}

elipsoidInterface::vx_type elipsoidInterface::
vx_default_value ()
{
  return vx_type (0.0F);
}

const elipsoidInterface::vy_type& elipsoidInterface::
vy () const
{
  return this->vy_.get ();
}

elipsoidInterface::vy_type& elipsoidInterface::
vy ()
{
  return this->vy_.get ();
}

void elipsoidInterface::
vy (const vy_type& x)
{
  this->vy_.set (x);
}

elipsoidInterface::vy_type elipsoidInterface::
vy_default_value ()
{
  return vy_type (0.0F);
}

const elipsoidInterface::vz_type& elipsoidInterface::
vz () const
{
  return this->vz_.get ();
}

elipsoidInterface::vz_type& elipsoidInterface::
vz ()
{
  return this->vz_.get ();
}

void elipsoidInterface::
vz (const vz_type& x)
{
  this->vz_.set (x);
}

elipsoidInterface::vz_type elipsoidInterface::
vz_default_value ()
{
  return vz_type (0.0F);
}


// planeInterface
// 

const planeInterface::vx_type& planeInterface::
vx () const
{
  return this->vx_.get ();
}

planeInterface::vx_type& planeInterface::
vx ()
{
  return this->vx_.get ();
}

void planeInterface::
vx (const vx_type& x)
{
  this->vx_.set (x);
}

planeInterface::vx_type planeInterface::
vx_default_value ()
{
  return vx_type (0.0F);
}

const planeInterface::vy_type& planeInterface::
vy () const
{
  return this->vy_.get ();
}

planeInterface::vy_type& planeInterface::
vy ()
{
  return this->vy_.get ();
}

void planeInterface::
vy (const vy_type& x)
{
  this->vy_.set (x);
}

planeInterface::vy_type planeInterface::
vy_default_value ()
{
  return vy_type (0.0F);
}

const planeInterface::vz_type& planeInterface::
vz () const
{
  return this->vz_.get ();
}

planeInterface::vz_type& planeInterface::
vz ()
{
  return this->vz_.get ();
}

void planeInterface::
vz (const vz_type& x)
{
  this->vz_.set (x);
}

planeInterface::vz_type planeInterface::
vz_default_value ()
{
  return vz_type (0.0F);
}


// lightInterface
// 

const lightInterface::id_type& lightInterface::
id () const
{
  return this->id_.get ();
}

lightInterface::id_type& lightInterface::
id ()
{
  return this->id_.get ();
}

void lightInterface::
id (const id_type& x)
{
  this->id_.set (x);
}

void lightInterface::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const lightInterface::r_type& lightInterface::
r () const
{
  return this->r_.get ();
}

lightInterface::r_type& lightInterface::
r ()
{
  return this->r_.get ();
}

void lightInterface::
r (const r_type& x)
{
  this->r_.set (x);
}

const lightInterface::x_type& lightInterface::
x () const
{
  return this->x_.get ();
}

lightInterface::x_type& lightInterface::
x ()
{
  return this->x_.get ();
}

void lightInterface::
x (const x_type& x)
{
  this->x_.set (x);
}

const lightInterface::y_type& lightInterface::
y () const
{
  return this->y_.get ();
}

lightInterface::y_type& lightInterface::
y ()
{
  return this->y_.get ();
}

void lightInterface::
y (const y_type& x)
{
  this->y_.set (x);
}

const lightInterface::z_type& lightInterface::
z () const
{
  return this->z_.get ();
}

lightInterface::z_type& lightInterface::
z ()
{
  return this->z_.get ();
}

void lightInterface::
z (const z_type& x)
{
  this->z_.set (x);
}


// tween
// 

const tween::type_type& tween::
type () const
{
  return this->type_.get ();
}

tween::type_type& tween::
type ()
{
  return this->type_.get ();
}

void tween::
type (const type_type& x)
{
  this->type_.set (x);
}

void tween::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const tween::property_type& tween::
property () const
{
  return this->property_.get ();
}

tween::property_type& tween::
property ()
{
  return this->property_.get ();
}

void tween::
property (const property_type& x)
{
  this->property_.set (x);
}

void tween::
property (::std::auto_ptr< property_type > x)
{
  this->property_.set (x);
}

const tween::from_type& tween::
from () const
{
  return this->from_.get ();
}

tween::from_type& tween::
from ()
{
  return this->from_.get ();
}

void tween::
from (const from_type& x)
{
  this->from_.set (x);
}

const tween::to_type& tween::
to () const
{
  return this->to_.get ();
}

tween::to_type& tween::
to ()
{
  return this->to_.get ();
}

void tween::
to (const to_type& x)
{
  this->to_.set (x);
}

const tween::start_type& tween::
start () const
{
  return this->start_.get ();
}

tween::start_type& tween::
start ()
{
  return this->start_.get ();
}

void tween::
start (const start_type& x)
{
  this->start_.set (x);
}

const tween::end_type& tween::
end () const
{
  return this->end_.get ();
}

tween::end_type& tween::
end ()
{
  return this->end_.get ();
}

void tween::
end (const end_type& x)
{
  this->end_.set (x);
}


// type
// 

type::
type (value v)
: ::xml_schema::string (_xsd_type_literals_[v])
{
}

type::
type (const char* v)
: ::xml_schema::string (v)
{
}

type::
type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

type::
type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

type::
type (const type& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

type& type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_type_literals_[v]);

  return *this;
}


// property
// 

property::
property (value v)
: ::xml_schema::string (_xsd_property_literals_[v])
{
}

property::
property (const char* v)
: ::xml_schema::string (v)
{
}

property::
property (const ::std::string& v)
: ::xml_schema::string (v)
{
}

property::
property (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

property::
property (const property& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

property& property::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_property_literals_[v]);

  return *this;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// sceneInterface
//

sceneInterface::
sceneInterface (const frames_type& frames,
                const w_type& w,
                const h_type& h,
                const d_type& d)
: ::xml_schema::type (),
  camera_ (::xml_schema::flags (), this),
  light_ (::xml_schema::flags (), this),
  sphere_ (::xml_schema::flags (), this),
  elipsoid_ (::xml_schema::flags (), this),
  plane_ (::xml_schema::flags (), this),
  frames_ (frames, ::xml_schema::flags (), this),
  width_ (width_default_value (), ::xml_schema::flags (), this),
  height_ (height_default_value (), ::xml_schema::flags (), this),
  w_ (w, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this),
  d_ (d, ::xml_schema::flags (), this),
  bred_ (bred_default_value (), ::xml_schema::flags (), this),
  bgreen_ (bgreen_default_value (), ::xml_schema::flags (), this),
  bblue_ (bblue_default_value (), ::xml_schema::flags (), this),
  glred_ (glred_default_value (), ::xml_schema::flags (), this),
  glgreen_ (glgreen_default_value (), ::xml_schema::flags (), this),
  glblue_ (glblue_default_value (), ::xml_schema::flags (), this)
{
}

sceneInterface::
sceneInterface (const sceneInterface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  camera_ (x.camera_, f, this),
  light_ (x.light_, f, this),
  sphere_ (x.sphere_, f, this),
  elipsoid_ (x.elipsoid_, f, this),
  plane_ (x.plane_, f, this),
  frames_ (x.frames_, f, this),
  width_ (x.width_, f, this),
  height_ (x.height_, f, this),
  w_ (x.w_, f, this),
  h_ (x.h_, f, this),
  d_ (x.d_, f, this),
  bred_ (x.bred_, f, this),
  bgreen_ (x.bgreen_, f, this),
  bblue_ (x.bblue_, f, this),
  glred_ (x.glred_, f, this),
  glgreen_ (x.glgreen_, f, this),
  glblue_ (x.glblue_, f, this)
{
}

sceneInterface::
sceneInterface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  camera_ (f, this),
  light_ (f, this),
  sphere_ (f, this),
  elipsoid_ (f, this),
  plane_ (f, this),
  frames_ (f, this),
  width_ (f, this),
  height_ (f, this),
  w_ (f, this),
  h_ (f, this),
  d_ (f, this),
  bred_ (f, this),
  bgreen_ (f, this),
  bblue_ (f, this),
  glred_ (f, this),
  glgreen_ (f, this),
  glblue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void sceneInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // camera
    //
    if (n.name () == "camera" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< camera_type > r (
        camera_traits::create (i, f, this));

      this->camera_.push_back (r);
      continue;
    }

    // light
    //
    if (n.name () == "light" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< light_type > r (
        light_traits::create (i, f, this));

      this->light_.push_back (r);
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (r);
      continue;
    }

    // elipsoid
    //
    if (n.name () == "elipsoid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elipsoid_type > r (
        elipsoid_traits::create (i, f, this));

      this->elipsoid_.push_back (r);
      continue;
    }

    // plane
    //
    if (n.name () == "plane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< plane_type > r (
        plane_traits::create (i, f, this));

      this->plane_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "frames" && n.namespace_ ().empty ())
    {
      this->frames_.set (frames_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "w" && n.namespace_ ().empty ())
    {
      this->w_.set (w_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      this->h_.set (h_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bred" && n.namespace_ ().empty ())
    {
      this->bred_.set (bred_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bgreen" && n.namespace_ ().empty ())
    {
      this->bgreen_.set (bgreen_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bblue" && n.namespace_ ().empty ())
    {
      this->bblue_.set (bblue_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "glred" && n.namespace_ ().empty ())
    {
      this->glred_.set (glred_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "glgreen" && n.namespace_ ().empty ())
    {
      this->glgreen_.set (glgreen_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "glblue" && n.namespace_ ().empty ())
    {
      this->glblue_.set (glblue_traits::create (i, f, this));
      continue;
    }
  }

  if (!frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "frames",
      "");
  }

  if (!width_.present ())
  {
    this->width_.set (width_default_value ());
  }

  if (!height_.present ())
  {
    this->height_.set (height_default_value ());
  }

  if (!w_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "w",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "h",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }

  if (!bred_.present ())
  {
    this->bred_.set (bred_default_value ());
  }

  if (!bgreen_.present ())
  {
    this->bgreen_.set (bgreen_default_value ());
  }

  if (!bblue_.present ())
  {
    this->bblue_.set (bblue_default_value ());
  }

  if (!glred_.present ())
  {
    this->glred_.set (glred_default_value ());
  }

  if (!glgreen_.present ())
  {
    this->glgreen_.set (glgreen_default_value ());
  }

  if (!glblue_.present ())
  {
    this->glblue_.set (glblue_default_value ());
  }
}

sceneInterface* sceneInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sceneInterface (*this, f, c);
}

sceneInterface::
~sceneInterface ()
{
}

// tweenInterface
//

tweenInterface::
tweenInterface ()
: ::xml_schema::type (),
  tween_ (::xml_schema::flags (), this)
{
}

tweenInterface::
tweenInterface (const tweenInterface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tween_ (x.tween_, f, this)
{
}

tweenInterface::
tweenInterface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tween_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void tweenInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tween
    //
    if (n.name () == "tween" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tween_type > r (
        tween_traits::create (i, f, this));

      this->tween_.push_back (r);
      continue;
    }

    break;
  }
}

tweenInterface* tweenInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tweenInterface (*this, f, c);
}

tweenInterface::
~tweenInterface ()
{
}

// cameraInterface
//

cameraInterface::
cameraInterface (const id_type& id,
                 const x_type& x,
                 const y_type& y,
                 const z_type& z)
: ::tweenInterface (),
  id_ (id, ::xml_schema::flags (), this),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this),
  z_ (z, ::xml_schema::flags (), this),
  vx1_ (vx1_default_value (), ::xml_schema::flags (), this),
  vy1_ (vy1_default_value (), ::xml_schema::flags (), this),
  vz1_ (vz1_default_value (), ::xml_schema::flags (), this),
  vx2_ (vx2_default_value (), ::xml_schema::flags (), this),
  vy2_ (vy2_default_value (), ::xml_schema::flags (), this),
  vz2_ (vz2_default_value (), ::xml_schema::flags (), this),
  vx3_ (vx3_default_value (), ::xml_schema::flags (), this),
  vy3_ (vy3_default_value (), ::xml_schema::flags (), this),
  vz3_ (vz3_default_value (), ::xml_schema::flags (), this)
{
}

cameraInterface::
cameraInterface (const cameraInterface& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::tweenInterface (x, f, c),
  id_ (x.id_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  vx1_ (x.vx1_, f, this),
  vy1_ (x.vy1_, f, this),
  vz1_ (x.vz1_, f, this),
  vx2_ (x.vx2_, f, this),
  vy2_ (x.vy2_, f, this),
  vz2_ (x.vz2_, f, this),
  vx3_ (x.vx3_, f, this),
  vy3_ (x.vy3_, f, this),
  vz3_ (x.vz3_, f, this)
{
}

cameraInterface::
cameraInterface (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::tweenInterface (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  x_ (f, this),
  y_ (f, this),
  z_ (f, this),
  vx1_ (f, this),
  vy1_ (f, this),
  vz1_ (f, this),
  vx2_ (f, this),
  vy2_ (f, this),
  vz2_ (f, this),
  vx3_ (f, this),
  vy3_ (f, this),
  vz3_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void cameraInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::tweenInterface::parse (p, f);

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vx1" && n.namespace_ ().empty ())
    {
      this->vx1_.set (vx1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vy1" && n.namespace_ ().empty ())
    {
      this->vy1_.set (vy1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vz1" && n.namespace_ ().empty ())
    {
      this->vz1_.set (vz1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vx2" && n.namespace_ ().empty ())
    {
      this->vx2_.set (vx2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vy2" && n.namespace_ ().empty ())
    {
      this->vy2_.set (vy2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vz2" && n.namespace_ ().empty ())
    {
      this->vz2_.set (vz2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vx3" && n.namespace_ ().empty ())
    {
      this->vx3_.set (vx3_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vy3" && n.namespace_ ().empty ())
    {
      this->vy3_.set (vy3_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vz3" && n.namespace_ ().empty ())
    {
      this->vz3_.set (vz3_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!vx1_.present ())
  {
    this->vx1_.set (vx1_default_value ());
  }

  if (!vy1_.present ())
  {
    this->vy1_.set (vy1_default_value ());
  }

  if (!vz1_.present ())
  {
    this->vz1_.set (vz1_default_value ());
  }

  if (!vx2_.present ())
  {
    this->vx2_.set (vx2_default_value ());
  }

  if (!vy2_.present ())
  {
    this->vy2_.set (vy2_default_value ());
  }

  if (!vz2_.present ())
  {
    this->vz2_.set (vz2_default_value ());
  }

  if (!vx3_.present ())
  {
    this->vx3_.set (vx3_default_value ());
  }

  if (!vy3_.present ())
  {
    this->vy3_.set (vy3_default_value ());
  }

  if (!vz3_.present ())
  {
    this->vz3_.set (vz3_default_value ());
  }
}

cameraInterface* cameraInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cameraInterface (*this, f, c);
}

cameraInterface::
~cameraInterface ()
{
}

// colorInterface
//

colorInterface::
colorInterface ()
: ::tweenInterface (),
  ared_ (ared_default_value (), ::xml_schema::flags (), this),
  agreen_ (agreen_default_value (), ::xml_schema::flags (), this),
  ablue_ (ablue_default_value (), ::xml_schema::flags (), this),
  dred_ (dred_default_value (), ::xml_schema::flags (), this),
  dgreen_ (dgreen_default_value (), ::xml_schema::flags (), this),
  dblue_ (dblue_default_value (), ::xml_schema::flags (), this),
  sred_ (sred_default_value (), ::xml_schema::flags (), this),
  sgreen_ (sgreen_default_value (), ::xml_schema::flags (), this),
  sblue_ (sblue_default_value (), ::xml_schema::flags (), this)
{
}

colorInterface::
colorInterface (const colorInterface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::tweenInterface (x, f, c),
  ared_ (x.ared_, f, this),
  agreen_ (x.agreen_, f, this),
  ablue_ (x.ablue_, f, this),
  dred_ (x.dred_, f, this),
  dgreen_ (x.dgreen_, f, this),
  dblue_ (x.dblue_, f, this),
  sred_ (x.sred_, f, this),
  sgreen_ (x.sgreen_, f, this),
  sblue_ (x.sblue_, f, this)
{
}

colorInterface::
colorInterface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::tweenInterface (e, f | ::xml_schema::flags::base, c),
  ared_ (f, this),
  agreen_ (f, this),
  ablue_ (f, this),
  dred_ (f, this),
  dgreen_ (f, this),
  dblue_ (f, this),
  sred_ (f, this),
  sgreen_ (f, this),
  sblue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void colorInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::tweenInterface::parse (p, f);

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ared" && n.namespace_ ().empty ())
    {
      this->ared_.set (ared_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "agreen" && n.namespace_ ().empty ())
    {
      this->agreen_.set (agreen_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ablue" && n.namespace_ ().empty ())
    {
      this->ablue_.set (ablue_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dred" && n.namespace_ ().empty ())
    {
      this->dred_.set (dred_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dgreen" && n.namespace_ ().empty ())
    {
      this->dgreen_.set (dgreen_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dblue" && n.namespace_ ().empty ())
    {
      this->dblue_.set (dblue_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sred" && n.namespace_ ().empty ())
    {
      this->sred_.set (sred_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sgreen" && n.namespace_ ().empty ())
    {
      this->sgreen_.set (sgreen_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sblue" && n.namespace_ ().empty ())
    {
      this->sblue_.set (sblue_traits::create (i, f, this));
      continue;
    }
  }

  if (!ared_.present ())
  {
    this->ared_.set (ared_default_value ());
  }

  if (!agreen_.present ())
  {
    this->agreen_.set (agreen_default_value ());
  }

  if (!ablue_.present ())
  {
    this->ablue_.set (ablue_default_value ());
  }

  if (!dred_.present ())
  {
    this->dred_.set (dred_default_value ());
  }

  if (!dgreen_.present ())
  {
    this->dgreen_.set (dgreen_default_value ());
  }

  if (!dblue_.present ())
  {
    this->dblue_.set (dblue_default_value ());
  }

  if (!sred_.present ())
  {
    this->sred_.set (sred_default_value ());
  }

  if (!sgreen_.present ())
  {
    this->sgreen_.set (sgreen_default_value ());
  }

  if (!sblue_.present ())
  {
    this->sblue_.set (sblue_default_value ());
  }
}

colorInterface* colorInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class colorInterface (*this, f, c);
}

colorInterface::
~colorInterface ()
{
}

// objectInterface
//

objectInterface::
objectInterface (const id_type& id,
                 const x_type& x,
                 const y_type& y,
                 const z_type& z)
: ::colorInterface (),
  id_ (id, ::xml_schema::flags (), this),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this),
  z_ (z, ::xml_schema::flags (), this),
  n_ (n_default_value (), ::xml_schema::flags (), this)
{
}

objectInterface::
objectInterface (const objectInterface& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::colorInterface (x, f, c),
  id_ (x.id_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  n_ (x.n_, f, this)
{
}

objectInterface::
objectInterface (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::colorInterface (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  x_ (f, this),
  y_ (f, this),
  z_ (f, this),
  n_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void objectInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::colorInterface::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "n" && n.namespace_ ().empty ())
    {
      this->n_.set (n_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!n_.present ())
  {
    this->n_.set (n_default_value ());
  }
}

objectInterface* objectInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class objectInterface (*this, f, c);
}

objectInterface::
~objectInterface ()
{
}

// sphereInterface
//

sphereInterface::
sphereInterface (const id_type& id,
                 const x_type& x,
                 const y_type& y,
                 const z_type& z,
                 const r_type& r)
: ::objectInterface (id,
                     x,
                     y,
                     z),
  r_ (r, ::xml_schema::flags (), this)
{
}

sphereInterface::
sphereInterface (const sphereInterface& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::objectInterface (x, f, c),
  r_ (x.r_, f, this)
{
}

sphereInterface::
sphereInterface (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::objectInterface (e, f | ::xml_schema::flags::base, c),
  r_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void sphereInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::objectInterface::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }
}

sphereInterface* sphereInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphereInterface (*this, f, c);
}

sphereInterface::
~sphereInterface ()
{
}

// elipsoidInterface
//

elipsoidInterface::
elipsoidInterface (const id_type& id,
                   const x_type& x,
                   const y_type& y,
                   const z_type& z,
                   const a_type& a,
                   const b_type& b,
                   const c_type& c)
: ::objectInterface (id,
                     x,
                     y,
                     z),
  a_ (a, ::xml_schema::flags (), this),
  b_ (b, ::xml_schema::flags (), this),
  c_ (c, ::xml_schema::flags (), this),
  vx_ (vx_default_value (), ::xml_schema::flags (), this),
  vy_ (vy_default_value (), ::xml_schema::flags (), this),
  vz_ (vz_default_value (), ::xml_schema::flags (), this)
{
}

elipsoidInterface::
elipsoidInterface (const elipsoidInterface& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::objectInterface (x, f, c),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  vx_ (x.vx_, f, this),
  vy_ (x.vy_, f, this),
  vz_ (x.vz_, f, this)
{
}

elipsoidInterface::
elipsoidInterface (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::objectInterface (e, f | ::xml_schema::flags::base, c),
  a_ (f, this),
  b_ (f, this),
  c_ (f, this),
  vx_ (f, this),
  vy_ (f, this),
  vz_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void elipsoidInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::objectInterface::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vx" && n.namespace_ ().empty ())
    {
      this->vx_.set (vx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vy" && n.namespace_ ().empty ())
    {
      this->vy_.set (vy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vz" && n.namespace_ ().empty ())
    {
      this->vz_.set (vz_traits::create (i, f, this));
      continue;
    }
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!vx_.present ())
  {
    this->vx_.set (vx_default_value ());
  }

  if (!vy_.present ())
  {
    this->vy_.set (vy_default_value ());
  }

  if (!vz_.present ())
  {
    this->vz_.set (vz_default_value ());
  }
}

elipsoidInterface* elipsoidInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class elipsoidInterface (*this, f, c);
}

elipsoidInterface::
~elipsoidInterface ()
{
}

// planeInterface
//

planeInterface::
planeInterface (const id_type& id,
                const x_type& x,
                const y_type& y,
                const z_type& z)
: ::objectInterface (id,
                     x,
                     y,
                     z),
  vx_ (vx_default_value (), ::xml_schema::flags (), this),
  vy_ (vy_default_value (), ::xml_schema::flags (), this),
  vz_ (vz_default_value (), ::xml_schema::flags (), this)
{
}

planeInterface::
planeInterface (const planeInterface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::objectInterface (x, f, c),
  vx_ (x.vx_, f, this),
  vy_ (x.vy_, f, this),
  vz_ (x.vz_, f, this)
{
}

planeInterface::
planeInterface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::objectInterface (e, f | ::xml_schema::flags::base, c),
  vx_ (f, this),
  vy_ (f, this),
  vz_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void planeInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::objectInterface::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "vx" && n.namespace_ ().empty ())
    {
      this->vx_.set (vx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vy" && n.namespace_ ().empty ())
    {
      this->vy_.set (vy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vz" && n.namespace_ ().empty ())
    {
      this->vz_.set (vz_traits::create (i, f, this));
      continue;
    }
  }

  if (!vx_.present ())
  {
    this->vx_.set (vx_default_value ());
  }

  if (!vy_.present ())
  {
    this->vy_.set (vy_default_value ());
  }

  if (!vz_.present ())
  {
    this->vz_.set (vz_default_value ());
  }
}

planeInterface* planeInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class planeInterface (*this, f, c);
}

planeInterface::
~planeInterface ()
{
}

// lightInterface
//

lightInterface::
lightInterface (const id_type& id,
                const r_type& r,
                const x_type& x,
                const y_type& y,
                const z_type& z)
: ::colorInterface (),
  id_ (id, ::xml_schema::flags (), this),
  r_ (r, ::xml_schema::flags (), this),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this),
  z_ (z, ::xml_schema::flags (), this)
{
}

lightInterface::
lightInterface (const lightInterface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::colorInterface (x, f, c),
  id_ (x.id_, f, this),
  r_ (x.r_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

lightInterface::
lightInterface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::colorInterface (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  r_ (f, this),
  x_ (f, this),
  y_ (f, this),
  z_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void lightInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::colorInterface::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      this->id_.set (r);
      continue;
    }

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }
}

lightInterface* lightInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lightInterface (*this, f, c);
}

lightInterface::
~lightInterface ()
{
}

// tween
//

tween::
tween (const type_type& type,
       const property_type& property,
       const from_type& from,
       const to_type& to,
       const start_type& start,
       const end_type& end)
: ::xml_schema::type (),
  type_ (type, ::xml_schema::flags (), this),
  property_ (property, ::xml_schema::flags (), this),
  from_ (from, ::xml_schema::flags (), this),
  to_ (to, ::xml_schema::flags (), this),
  start_ (start, ::xml_schema::flags (), this),
  end_ (end, ::xml_schema::flags (), this)
{
}

tween::
tween (const tween& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  property_ (x.property_, f, this),
  from_ (x.from_, f, this),
  to_ (x.to_, f, this),
  start_ (x.start_, f, this),
  end_ (x.end_, f, this)
{
}

tween::
tween (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  property_ (f, this),
  from_ (f, this),
  to_ (f, this),
  start_ (f, this),
  end_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void tween::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }

    if (n.name () == "property" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< property_type > r (
        property_traits::create (i, f, this));

      this->property_.set (r);
      continue;
    }

    if (n.name () == "from" && n.namespace_ ().empty ())
    {
      this->from_.set (from_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      this->to_.set (to_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "start" && n.namespace_ ().empty ())
    {
      this->start_.set (start_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "end" && n.namespace_ ().empty ())
    {
      this->end_.set (end_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!property_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "property",
      "");
  }

  if (!from_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "from",
      "");
  }

  if (!to_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "to",
      "");
  }

  if (!start_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "start",
      "");
  }

  if (!end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "end",
      "");
  }
}

tween* tween::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tween (*this, f, c);
}

tween::
~tween ()
{
}

// type
//

type::
type (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_type_convert ();
}

type::
type (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_type_convert ();
}

type::
type (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_type_convert ();
}

type* type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type (*this, f, c);
}

type::value type::
_xsd_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_type_indexes_,
                    _xsd_type_indexes_ + 1,
                    *this,
                    c));

  if (i == _xsd_type_indexes_ + 1 || _xsd_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const type::
_xsd_type_literals_[1] =
{
  "linear"
};

const type::value type::
_xsd_type_indexes_[1] =
{
  ::type::linear
};

// property
//

property::
property (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_property_convert ();
}

property::
property (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_property_convert ();
}

property::
property (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_property_convert ();
}

property* property::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class property (*this, f, c);
}

property::value property::
_xsd_property_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_property_literals_);
  const value* i (::std::lower_bound (
                    _xsd_property_indexes_,
                    _xsd_property_indexes_ + 25,
                    *this,
                    c));

  if (i == _xsd_property_indexes_ + 25 || _xsd_property_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const property::
_xsd_property_literals_[25] =
{
  "x",
  "y",
  "z",
  "vx",
  "vy",
  "vz",
  "vx1",
  "vx2",
  "vx3",
  "vy1",
  "vy2",
  "vy3",
  "vz1",
  "vz2",
  "vz3",
  "ared",
  "agreen",
  "ablue",
  "dred",
  "dgreen",
  "dblue",
  "sred",
  "sgreen",
  "sblue",
  "n"
};

const property::value property::
_xsd_property_indexes_[25] =
{
  ::property::ablue,
  ::property::agreen,
  ::property::ared,
  ::property::dblue,
  ::property::dgreen,
  ::property::dred,
  ::property::n,
  ::property::sblue,
  ::property::sgreen,
  ::property::sred,
  ::property::vx,
  ::property::vx1,
  ::property::vx2,
  ::property::vx3,
  ::property::vy,
  ::property::vy1,
  ::property::vy2,
  ::property::vy3,
  ::property::vz,
  ::property::vz1,
  ::property::vz2,
  ::property::vz3,
  ::property::x,
  ::property::y,
  ::property::z
};

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::sceneInterface >
scene (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::sceneInterface > r (
    ::scene (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::sceneInterface >
scene (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::sceneInterface > r (
    ::scene (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::sceneInterface >
scene (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::sceneInterface > r (
    ::scene (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::sceneInterface >
scene (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scene (isrc, f, p);
}

::std::auto_ptr< ::sceneInterface >
scene (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scene (isrc, h, f, p);
}

::std::auto_ptr< ::sceneInterface >
scene (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scene (isrc, h, f, p);
}

::std::auto_ptr< ::sceneInterface >
scene (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scene (isrc, f, p);
}

::std::auto_ptr< ::sceneInterface >
scene (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scene (isrc, h, f, p);
}

::std::auto_ptr< ::sceneInterface >
scene (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scene (isrc, h, f, p);
}

::std::auto_ptr< ::sceneInterface >
scene (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::sceneInterface > r (
    ::scene (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::sceneInterface >
scene (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::sceneInterface > r (
    ::scene (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::sceneInterface >
scene (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::sceneInterface > r (
    ::scene (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::sceneInterface >
scene (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::sceneInterface > r (
      ::scene (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "scene" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::sceneInterface > r (
      ::xsd::cxx::tree::traits< ::sceneInterface, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "scene",
    "");
}

::std::auto_ptr< ::sceneInterface >
scene (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "scene" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::sceneInterface > r (
      ::xsd::cxx::tree::traits< ::sceneInterface, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "scene",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

